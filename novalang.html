<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>NovaLang v4.1</title>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --text-color: #d4d4d4;
      --primary-color: #4ec9b0; /* Teal para keywords */
      --secondary-color: #c586c0; /* Roxo para if/loop */
      --function-color: #dcdcaa; /* Amarelo para funções */
      --string-color: #ce9178; /* Laranja para strings */
      --number-color: #b5cea8; /* Verde claro para números */
      --comment-color: #6a9955; /* Verde escuro para comentários */
      --error-color: #f44747;
      --cursor-color: #aeafad;
      --border-color: #444;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: 'Consolas', 'Menlo', 'Monaco', monospace;
      padding: 20px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin: 0;
      box-sizing: border-box;
    }

    h1 {
      color: var(--primary-color);
      margin-top: 0;
    }

    .main-container {
      display: flex;
      gap: 20px;
      flex-grow: 1;
      min-height: 0; /* Fix for flexbox overflow */
    }
    
    .editor-column, .output-column {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .editor-wrapper {
      position: relative;
      flex-grow: 1;
      font-size: 16px;
      line-height: 1.5;
    }

    #code, #highlighting-layer {
      margin: 0;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      letter-spacing: 0.5px;
      white-space: pre;
      overflow-wrap: normal;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      overflow: auto;
    }

    #code {
      z-index: 1;
      color: transparent;
      background: transparent;
      caret-color: var(--cursor-color);
      resize: none;
    }

    #highlighting-layer {
      z-index: 0;
      pointer-events: none;
    }

    /* Colorização de Sintaxe */
    .hl-keyword { color: var(--secondary-color); font-weight: bold; }
    .hl-let { color: var(--primary-color); }
    .hl-function-call { color: var(--function-color); }
    .hl-string { color: var(--string-color); }
    .hl-number { color: var(--number-color); }
    .hl-comment { color: var(--comment-color); font-style: italic; }

    /* Autocomplete */
    #autocomplete {
      display: none;
      position: absolute;
      background: #252526;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      width: 200px;
      max-height: 150px;
      overflow-y: auto;
      font-size: 14px;
      z-index: 100;
    }
    #autocomplete div {
      padding: 5px 10px;
      cursor: pointer;
      color: var(--text-color);
    }
    #autocomplete div:hover,
    #autocomplete .selected {
      background: #094771;
    }

    button {
      background: var(--primary-color);
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: var(--bg-color);
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 10px;
      transition: background-color 0.2s;
    }
    button:hover {
      background: #62dcc0;
    }

    #output {
      background: #000;
      color: #ccc;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      white-space: pre-wrap;
      flex-grow: 1;
      overflow-y: auto;
    }
    .output-ok { color: #0f0; }
    .output-error { color: var(--error-color); font-weight: bold; }
    
    #cursor-helper {
        position: absolute;
        visibility: hidden;
        white-space: pre-wrap;
    }

  </style>
</head>
<body>
  <h1>NovaLang v4.1</h1>
  <div class="main-container">
    <div class="editor-column">
      <button onclick="runInterpreter()">Executar</button>
      <div class="editor-wrapper">
        <div id="highlighting-layer"></div>
        <textarea id="code" spellcheck="false" oninput="onCodeInput()" onscroll="onCodeScroll()" onkeydown="onCodeKeyDown()">
// NovaLang v4.1 - Teste completo

// Definição de função com retorno
func calcularArea(lado) {
  let area = lado ^ 2
  print("A área de um quadrado de lado " + lado + " é " + area)
  return area // Funções agora podem retornar valores!
}

// Chamada de função e atribuição do retorno
let ladoQuadrado = 5
let resultadoArea = calcularArea(ladoQuadrado) // Isso agora funciona!
print("Resultado retornado: " + resultadoArea)

// Estrutura condicional com = e ==
if (resultadoArea = 25) {
  print("Teste de 'if com =' passou!")
}

if (ladoQuadrado == 5) {
  print("Teste de 'if com ==' passou!")
}

// Loop
loop (3) {
  print("Iteração do loop...")
}

// Funções matemáticas novas
print("Raiz de 16: " + sqrt 16)
print("Fatorial de 5: " + 5!)
print("Potência 2^8: " + (2 ^ 8))
print("Seno de 90 (rad): " + sin(1.57))
print("Valor absoluto de -10: " + abs(-10))

// Erro proposital (descomente para testar)
// print("Isso vai dar erro"
        </textarea>
        <div id="autocomplete"></div>
        <div id="cursor-helper"></div>
      </div>
    </div>
    <div class="output-column">
      <h2>Saída:</h2>
      <pre id="output"></pre>
    </div>
  </div>

  <script>
    // =======================================================
    // NÚCLEO DO INTERPRETADOR (essa parte é daora)
    // =======================================================
    class Interpreter {
      constructor() {
        this.vars = { 'PI': Math.PI };
        this.funcs = {};
        this.output = '';
        this.currentLineIndex = 0;
        this.returnValue = null;
      }

      log(text, type = 'ok') {
        const className = type === 'error' ? 'output-error' : 'output-ok';
        this.output += `<span class="${className}">${text}</span>\n`;
      }

      evaluateExpression(expr, scope = {}) {
        const localVars = { ...this.vars, ...scope };
        try {
          expr = String(expr).trim()
            .replace(/sqrt\s+([0-9.-]+|\w+)/g, 'Math.sqrt($1)')
            .replace(/(\d+)!/g, (_, n) => { let r=1; for(let i=2; i<=n; i++) r*=i; return r; })
            .replace(/\^/g, '**')
            .replace(/(abs|round|floor|ceil|sin|cos|tan)\s*\((.*?)\)/g, 'Math.$1($2)')
            .replace(/(?<![=<>!])=(?!=)/g, '==');

          const varNames = Object.keys(localVars);
          const varValues = Object.values(localVars);
          return new Function(...varNames, `return ${expr}`)(...varValues);
        } catch (e) {
            throw new Error(`Erro ao avaliar a expressão "${expr}": ${e.message}`);
        }
      }
      
      _executeFunctionCall(name, argsStr, scope = {}) {
          const fn = this.funcs[name];
          if (!fn) throw new Error(`Função '${name}' não foi definida.`);
          
          const args = argsStr ? argsStr.split(',').map(a => this.evaluateExpression(a.trim(), scope)) : [];
          if (fn.params.length !== args.length) {
              throw new Error(`Função '${name}' espera ${fn.params.length} argumentos, mas recebeu ${args.length}.`);
          }
          
          const funcScope = {};
          fn.params.forEach((param, index) => { funcScope[param] = args[index]; });

          const funcInterpreter = new Interpreter();
          funcInterpreter.vars = { ...this.vars, ...scope, ...funcScope };
          funcInterpreter.funcs = { ...this.funcs };
          funcInterpreter.run(fn.body.join('\n'));
          
          this.output += funcInterpreter.output;
          return funcInterpreter.returnValue;
      }

      readBlock(lines, startIndex) {
        const block = [];
        let openBraces = 1;
        let i = startIndex + 1;
        while (i < lines.length) {
          let line = lines[i];
          const commentIndex = line.indexOf('//');
          if (commentIndex !== -1) {
              line = line.substring(0, commentIndex);
          }

          if (line.includes('{')) openBraces++;
          if (line.includes('}')) openBraces--;

          if (openBraces === 0) {
            // Pega o conteúdo antes do '}' final
            const finalContent = lines[i].substring(0, lines[i].lastIndexOf('}'));
            if (finalContent.trim()) {
              block.push(finalContent);
            }
            return { block, endIndex: i };
          }
          block.push(lines[i]);
          i++;
        }
        throw new Error("Bloco de código não foi fechado. Esperado '}' correspondente.");
      }

      run(code) {
        const lines = code.split('\n');
        for (let i = 0; i < lines.length; i++) {
            this.currentLineIndex = i;
            
            // Primeiro, isso remove os comentários da linha
            let line = lines[i];
            const commentIndex = line.indexOf('//');
            if (commentIndex !== -1) {
                line = line.substring(0, commentIndex);
            }
            line = line.trim();

            // Se a linha ficar vazia após remover o comentário, pula
            if (line === '') {
                continue;
            }

            try {
                if (line.startsWith('return')) {
                    const expr = line.substring(6).trim();
                    this.returnValue = this.evaluateExpression(expr);
                    break;
                }

                if (line.startsWith('func ')) {
                    const match = line.match(/func\s+(\w+)\s*\((.*?)\)\s*\{/);
                    if (!match) throw new Error("Sintaxe de função inválida. Use: func nome(params) {");
                    const [, name, paramsStr] = match;
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    const { block, endIndex } = this.readBlock(lines, i);
                    this.funcs[name] = { params, body: block };
                    i = endIndex;
                }
                
                else if (line.startsWith('let ')) {
                    const match = line.match(/let\s+(\w+)\s*=\s*(.*)/);
                    if (!match) throw new Error("Sintaxe de variável inválida. Use: let nome = valor");
                    const [, name, expr] = match;
                    
                    const funcCallMatch = expr.match(/^(\w+)\s*\((.*)\)\s*$/);
                    if (funcCallMatch && this.funcs[funcCallMatch[1]]) {
                        this.vars[name] = this._executeFunctionCall(funcCallMatch[1], funcCallMatch[2]);
                    } else {
                        this.vars[name] = this.evaluateExpression(expr);
                    }
                }

                else if (line.startsWith('print(')) {
                    if (!line.endsWith(')')) throw new Error("Comando 'print' incompleto. Faltando ')' no final.");
                    const expr = line.slice(6, -1);
                    this.log(this.evaluateExpression(expr));
                }
                
                else if (line.startsWith('if')) {
                    const match = line.match(/if\s*\((.*?)\)\s*\{/);
                    if (!match) throw new Error("Sintaxe de 'if' inválida. Use: if (condicao) {");
                    const [, condition] = match;
                    const { block, endIndex } = this.readBlock(lines, i);
                    if (this.evaluateExpression(condition)) {
                        const tempInterpreter = new Interpreter();
                        tempInterpreter.vars = { ...this.vars };
                        tempInterpreter.funcs = { ...this.funcs };
                        tempInterpreter.run(block.join('\n'));
                        this.output += tempInterpreter.output;
                    }
                    i = endIndex;
                }

                else if (line.startsWith('loop')) {
                    const match = line.match(/loop\s*\((.*?)\)\s*\{/);
                    if (!match) throw new Error("Sintaxe de 'loop' inválida. Use: loop (numero) {");
                    const [, countExpr] = match;
                    const count = this.evaluateExpression(countExpr);
                    const { block, endIndex } = this.readBlock(lines, i);
                    for (let j = 0; j < count; j++) {
                        const tempInterpreter = new Interpreter();
                        tempInterpreter.vars = { ...this.vars, j };
                        tempInterpreter.funcs = { ...this.funcs };
                        tempInterpreter.run(block.join('\n'));
                        this.output += tempInterpreter.output;
                    }
                    i = endIndex;
                }

                else {
                    const funcCallMatch = line.match(/^(\w+)\s*\((.*)\)\s*$/);
                    const assignmentMatch = line.match(/^(\w+)\s*=\s*(.*)/);

                    if (funcCallMatch && this.funcs[funcCallMatch[1]]) {
                        this._executeFunctionCall(funcCallMatch[1], funcCallMatch[2]);
                    } else if (assignmentMatch && this.vars.hasOwnProperty(assignmentMatch[1])) {
                       const [, name, expr] = assignmentMatch;
                       this.vars[name] = this.evaluateExpression(expr);
                    } else {
                        throw new Error(`Comando ou sintaxe não reconhecida: "${line}"`);
                    }
                }
            } catch (e) {
                this.log(`Linha ${this.currentLineIndex + 1}: ${e.message}`, 'error');
                break;
            }
        }
        return this.output;
      }
    }


    // =======================================================
    // LÓGICA DA UI (EDITOR, HIGHLIGHTING, AUTOCOMPLETE)
    // =======================================================
    const textarea = document.getElementById('code');
    const highlightingLayer = document.getElementById('highlighting-layer');
    const outputEl = document.getElementById('output');
    const autocompleteEl = document.getElementById('autocomplete');

    const keywords = ["let", "func", "print", "if", "loop", "return"];
    const builtInFuncs = ["sqrt", "abs", "round", "floor", "ceil", "sin", "cos", "tan"];
    const allSuggestions = [...keywords, ...builtInFuncs];
    let autocompleteIndex = 0;

    function runInterpreter() {
        const code = textarea.value;
        const interpreter = new Interpreter();
        const result = interpreter.run(code);
        outputEl.innerHTML = result;
    }

    function onCodeInput() {
      updateHighlighting();
      handleAutocomplete();
    }
    
    function onCodeScroll() {
      highlightingLayer.scrollTop = textarea.scrollTop;
      highlightingLayer.scrollLeft = textarea.scrollLeft;
    }
    
    function updateHighlighting() {
        let code = textarea.value;
        code = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

        const placeholders = [];
        code = code.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, (match) => {
            placeholders.push(`<span class="hl-string">${match}</span>`);
            return `__PLACEHOLDER_${placeholders.length - 1}__`;
        });
        code = code.replace(/(\/\/.*)/g, (match) => {
            placeholders.push(`<span class="hl-comment">${match}</span>`);
            return `__PLACEHOLDER_${placeholders.length - 1}__`;
        });

        code = code.replace(/\b(if|loop|func|return)\b/g, '<span class="hl-keyword">$1</span>');
        code = code.replace(/\b(let)\b/g, '<span class="hl-let">$1</span>');
        code = code.replace(/\b(\d+(\.\d+)?)\b/g, '<span class="hl-number">$1</span>');
        code = code.replace(/(\w+)\s*(?=\()/g, '<span class="hl-function-call">$1</span>');
        
        code = code.replace(/__PLACEHOLDER_(\d+)__/g, (_, index) => placeholders[index]);

        highlightingLayer.innerHTML = code + '\n';
        onCodeScroll();
    }
    
    function getCursorXY() {
        const helper = document.getElementById('cursor-helper') || document.createElement('div');
        helper.id = 'cursor-helper';
        document.body.appendChild(helper);
        const textareaStyles = window.getComputedStyle(textarea);
        
        ['font', 'letterSpacing', 'lineHeight', 'padding', 'border', 'width'].forEach(prop => {
            helper.style[prop] = textareaStyles[prop];
        });
        helper.style.position = 'absolute';
        helper.style.visibility = 'hidden';
        helper.style.whiteSpace = 'pre-wrap';

        const textUpToCursor = textarea.value.substring(0, textarea.selectionStart);
        helper.textContent = textUpToCursor;

        const span = document.createElement('span');
        span.textContent = '.';
        helper.appendChild(span);

        const x = span.offsetLeft;
        const y = span.offsetTop;
        
        helper.textContent = '';
        return { x, y };
    }

    function handleAutocomplete() {
        const textUpToCursor = textarea.value.substring(0, textarea.selectionStart);
        const currentWordMatch = textUpToCursor.match(/(\w+)$/);
        
        if (!currentWordMatch) {
            autocompleteEl.style.display = 'none';
            return;
        }

        const currentWord = currentWordMatch[1];
        const suggestions = allSuggestions.filter(k => k.startsWith(currentWord));

        if (suggestions.length === 0 || currentWord.length === 0) {
            autocompleteEl.style.display = 'none';
            return;
        }

        autocompleteIndex = 0;
        autocompleteEl.innerHTML = suggestions.map((s, idx) => 
            `<div class="${idx === 0 ? 'selected' : ''}" onclick="selectAutocompleteItem('${s}', '${currentWord}')">${s}</div>`
        ).join('');
        
        const { x, y } = getCursorXY();
        const lineHeight = parseFloat(window.getComputedStyle(textarea).lineHeight);
        
        autocompleteEl.style.display = 'block';
        autocompleteEl.style.left = `${textarea.offsetLeft + x - textarea.scrollLeft}px`;
        autocompleteEl.style.top = `${textarea.offsetTop + y - textarea.scrollTop + lineHeight}px`;
    }

    function selectAutocompleteItem(suggestion, wordToReplace) {
        const start = textarea.selectionStart - wordToReplace.length;
        textarea.setRangeText(suggestion, start, textarea.selectionStart, 'end');
        autocompleteEl.style.display = 'none';
        textarea.focus();
        onCodeInput();
    }
    
    function onCodeKeyDown(e) {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = textarea.selectionStart;
        textarea.setRangeText("  ", start, start, "end");
        onCodeInput();
        return;
      }

      if (autocompleteEl.style.display === 'block') {
        const options = autocompleteEl.querySelectorAll('div');
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          autocompleteIndex = (autocompleteIndex + 1) % options.length;
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          autocompleteIndex = (autocompleteIndex - 1 + options.length) % options.length;
        } else if (e.key === 'Enter' || e.key === 'Tab') {
          e.preventDefault();
          options[autocompleteIndex].click();
        } else if (e.key === 'Escape') {
          autocompleteEl.style.display = 'none';
        }
        
        options.forEach((opt, idx) => opt.classList.toggle('selected', idx === autocompleteIndex));
      }
    }

    document.addEventListener('DOMContentLoaded', () => { updateHighlighting(); });
  </script>
</body>
</html>

